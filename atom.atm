¬Test
a: i4 = b ¬¬ *s

{
 i: i4
 {
    i: i8 = b_ron
 }
}

my_arr: >i4
my_arr_ptr: >>i4 = &my_arr
a: i4 = 143
*a[b] = 12
b: i8

*a = n

a[12];


for i: i4 to i < 10 do i++ {
    b: i8 = 15;
    print("Hello world!");
    {
        j: i8 = b + 1
    }
}

for i: i8 to 10 do i++ {
    my_arr[i] = i * 2
    print("Hello world!")
}


¬ This is a test script for the atom lang

¬*
    behold the elusive multiline comment
    gaze upon its ability to traverse multiple lines
*¬

i ¬*THis is an obtrusive comment*¬ : i4 = a++ + b * -c;

main(12 + 2, 18 * 9, 8, a++ + b * -c)

a: bool = not b;
b: n8 = 2 + funca(1 + 3)
c: i4 = (2 + -12.3524336645244) * 16 / 3 * *a - -b + funca(12 + 2, 13);
d: bool = a++
ret 1 - a * b

a = 123;

top_level: i4

func main(argc: i4, argv: >>chr): i4 {
    func cleanup(my_str: str, my_other_int: i8, my_real: r8): i4 {
        my_int: i8 = i_dont_exist

        ret my_int
    }

    proc cleans(what: chr, my_chr: >chr) {
        yup: str = &what;
    }

    a: i4 = 0

    bar: i4 = 0b00110

    times 10 {
        print("Hello world!"); a++;
    }

    times 20 {print("Hello world!")} ¬ todo parser does not yet allow single statement parsing

    b: i4 = 0b110

¬¬    c, d, e, f: i4 = 0xFFFC, 0o7723, 0d9876, 0t2112

    g: i8 = 0x7762

    r: r4 = 12.1123

    pq: bool = not true;

    test: bool = true and false

    my_arr: >i4 = malloc(10);

    if my_arr == nav {
        ret -1 as n4;
    } elif my_arr > 1 {
        print("AAAAAAAAAAAAAAAAAA");
    } elif my_arr < 1 {
        print("WElcomne");
    } else {
        print("nice")
    }

    *(my_arr + 9) = *my_arr * 2

    my_char: chr = 'c'

    mychar: chr

    a : >i4

    ret a - a;
}

a = b = 14

b: i4 = a[12] + b[b] + c[a[12] + d[b[c * 2]] * function(a, b[2])]

*a = 12
b[a] = 14
*a[12] = b
*a[b] = 12

-funca(a[b++ * ++c] - -1, -b++)

for i: i4 = 10; j: i8 to 10 do i++ {
    my_arr[i] = i * 2
}

¬*    comment
part of a comment*¬