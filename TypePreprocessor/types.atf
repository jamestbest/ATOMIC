// WARNING
//  In the current parser for atfs there are alot of size restrictions that are
//   not written, e.g. the number of types or the max size (bytes) a type can be

// TYPEFIX is the possible pre/post fix values to the types
//  E.g. pointer (>), reference (&)
TYPEFIX DEFAULT PREFIX
 POINTER ptr > SIZE 8
// ARRS  arrS []
// ARRD  arrD [..]
// ARRL  arrL [*]

// The types create keywords, and general types for the language
// OVER designates sizes
// REQUIRE means that the type cannot exist unless it has the TYPEFIX specified
// VIRTUAL means the type should exist but is not part of the type matrix i.e. cannot be used in calculations
//  WARNING: multiple names for a GTYPE is now depr, and will be removed
TYPES
 INTEGER PREFIX i OVER 1 2 4 8
 NATURAL PREFIX n OVER 1 2 4 8
 REAL PREFIX r OVER 4 8 10
 RATIONAL PREFIX q OVER 4 8 16
 CHAR chr SIZE 1
 STRING str SIZE 16
 BOOLEAN bool SIZE 1
 VOID void REQUIRE POINTER
 FUNCTION func VIRTUAL REQUIRE POINTER
 PROCEDURE proc VIRTUAL REQUIRE POINTER
 STRUCT struct VIRTUAL

// Operators gives a list of operator names, their symbol, the associativity, and precedence
OPERATORS DEFAULT LEFT BI
 PLUS  +   5
 MINUS -   5

 MULT  *   5
 DIV   /   5

 MOD   %   5
 POW   ^   5

 BAND  &   5
 BOR   |   5
 BXOR  |-  5

 SHL   <<  5
 SHR   >>  5
 
 ASS_PLUS   +=  5
 ASS_MINUS  -=  5 
 ASS_MULT   *=  5
 ASS_DIV    /=  5
 ASS_MOD    %=  5
 ASS_POW    ^=  5
 ASS_BOR    |=  5
 ASS_BAND   &=  5
 ASS_SHL    <<= 5
 ASS_SHR    >>= 5
 
 LAND   &&  5
 LOR    ||  5
 LXOR   |-| 5
 
 LNOT   !   5   PREFIX
 BNOT   ~   5   PREFIX
 
 INC    ++  5   UNARY
 DEC    --  5   UNARY
 
 AMPERSAND  &   5   PREFIX
 TYPE_CONV  as  5
 
 ASSIGN =   5
 
 EQU    ==  5
 NEQ    !=  5
 LESS   <   5
 MORE   >   5
 LESSEQ <=  5
 MOREEQ >=  5
 
 DEREF  *   5   PREFIX
 
 SWAP   <>  5
 RANGE  ..  5
 ARROW  ->  5
 DOT    .   5

// Alias is just used in this file, a short hand for types
ALIASES
 INTEGRAL = INTEGER | NATURAL
 NUMERIC = INTEGER | NATURAL | REAL | RATIONAL
 ALPHABETICAL = CHAR | STRING

// Coercions are what types can be implicitly converted to which when validating that an
//  operator can be done on two given operand types
// Coercions can only happen where a destination type's size is >= to the source type's size
COERCIONS
 CHAR <-> INTEGRAL
 INTEGER <-> NATURAL
 NUMERIC|POINTER -> BOOLEAN
 BOOLEAN -> NUMERIC
 INTEGRAL <-> POINTER
 INTEGRAL -> REAL
 TYPE -> NATURAL

// LR values are the difference between locator values and... values
//  LVALUE= RVALUE
//  &LVALUE
//
// The system here is defining what type of expression an operation creates
//  E.g. a dereference operation could create an LVALUE -> *x
//   A variable is always an LVALUE, dot and arrow struct.x, structptr->x
LRVALUES
 LVALUE= DEREF VARIABLE ARROW DOT
 RVALUE= ALL

// The types that are valid for a given operator
// ; designates a new pattern
// Single types mean symmetric, aliases expand to repeated ors
//  e.g. ALPHABETICAL; => CHAR|STRING;
//  it does not mean that CHAR + STRING is valid
//   UNLESS YOU DO ALPHABETICAL || ALPHABETICAL;
// || means that there is a strict type on one side but that it can occur on the left or right
// && means that there is a strict type that must occur on that side
// aliased types within || and && expand to repeated `|` i.e. || ALPHABETICAL => || CHAR|STRING
// -> TYPE is the explicit output type designator, meaning that the output of the operator is not
//   dependant on the types but instead the specified type, appears after operator name before `=`
//   this type can also be UNWRAP which is internal type for removing a typefix layer
// There are TWO types of RULES type maps & LR rules, type maps are for general arithmetic ops
//  they allow certain types to be operands
//  LR rules are for those that use LValue and RValue they can only have one rule
OPERANDS
 PLUS= NUMERIC; ALPHABETICAL; POINTER || INTEGER|NATURAL|POINTER
 MINUS= NUMERIC; CHAR; POINTER && INTEGER|NATURAL|POINTER

 MULT= NUMERIC; CHAR || INTEGER|NATURAL
 LOR -> BOOLEAN= NUMERIC; BOOLEAN

 SWAP -> VOID= LVALUE
 TYPE_CONV -> RIGHT= RVALUE && TYPE

 DEREF -> UNWRAP= POINTER
 AMPERSAND -> WRAP POINTER= LVALUE
 ASSIGN -> LEFT= LVALUE && LEFT

 LESS -> BOOLEAN= NUMERIC
