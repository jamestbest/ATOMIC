b : i4 = 1 + (2 + 3)
a := 1 + b++ * 3
c := (1 + ++b) * 3

testFunc21a(12, 13, 14, a, b, 10, test())
unique : bool = true

a <> b

¬[1..10.101]

printf(test)
b := test(1) + 3

¬maybe multiple returns from a function?

¬a,b,c : i4 = 1+2* 3,3,5 + 2

a := test(1 + test(2))

testc : i4

testcd : bool; testdc : string[..]

testd := 5

¬ctest := []

a := test(1 + 2)
b := 10 + test(1 + 2, a) + 12

entry func main(i : i4, j : i8, k : r4) : i4 {
    name : string = "James"

    printHello(name)

¬    nums : i4[] = [1..10]
¬
¬    nums2 : i8[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
¬
¬    nums3 : i8[] = nums

    ¬*
    for num in nums {
        printf("The num is {num}")
    }
    *¬

    k:=10

    for i:=10 to 0 do i-- {           ¬ can be for i=10 to 0 {
        ¬printf("The value is {i}")
        k:=10
        k=10
        i=10
        j:=10
        ¬*
        if i == 5 {
            brk
        }
        *¬
    }

    k += 10

    times 10 {
        printf("Hello")
        k+=10
    }

    a : i4 = 10 + 2
    b : i4 = 20
    d : i8 = 30

    times 12 + 2 * a + b / (c + d) {
        printf("Hello adventurer")
    }

    printf("The value of a is {a} and b is {b} as a and b have swapped values")

    isAlive := true
    isAlive = a
    isAlive = a > b

    age := 18

    if (test) {
        printf("test1")
    } elif test2 {
        printf("Test2")
    } else {
        printf("Test3")
    }

    if isAlive {
        printf("The person is alive")
        if age > 18 {
            printf("The person is an adult")
        } elif age < 1 {
            printf("The person is a baby")
        } else {
            printf("The person is a child")
        }
    } else {
        printf("The person is dead")
    }

    testFunc(12, 13, 14, a, b, 10, test())

    ret 1 ^ 1
}

proc printHello(name : string){
    printf("hello {name}")

    asbdasd7u23987adha : i4 = 1

    test : r8 = 12.123

    ¬ this is a comment
    ¬*
        this is a multiline comment
        that takes up multiple lines
    *¬

    a : i4 = 10

    for i:=0 to 10 do i+=2 {
        j:=0
        j = 10

        for j=0 to 10 do j++ {
            j = 10
        }
    }
}



a : i4 = 10 + test()

a : i4 = 10 + test(1 + 2, a)

b : i4 = 20

a := ((1 + 2) * 3)

b := 10 + test(1 + 2, a) + 12
¬ change shunting yard to allow multiple expressions e.g. 1 + test(2 + b) * 3
test(1, test(2, 3))

test(1 + 2,3)

b := 10 + test(1 + 2, a) + 12

a := 1 + test(2 + test(a * 2, 3), c + 2) * 3

b := 10

¬a := test(1 + 2, b + test(1 + 2))

a := test(1 + test(2), 3 * test(1 + 2 * 3, a) + 12) + 44

b := test(1) + 3

c := 1 + 2 * 3 + (4 + 5) * 6

d := test(1) + 2

ret 12

teste : i4 = 12
teste = 5

varNotDefTest := 5.012

entry func add(num1 : i4, num2 : i4) : i4 {
    ret num1 + num2
}

a := [1+2*3,2,3]
b := [[1,2],[1,2+3],3]
c := []
d := [1..10]

a,b,c : string = "a","b";

f := 1 + 2; g := 3 + 4;

g:= -(1+2)

a := 1 + \
     2
b := 2

entry func fact(n:i4) : i4 {
    if (n == 1){
        ret 1
    }

    ret n * fact(n-1)
}

rec func functionTwo (a : i4, b : i4, c : i4) : i4 {
    header {
        message: string = "values are: "
    }

    if a > 100 {
        print(message)
        ret a
    }

    a += b * (c |- 3)
    message += a as string
}

a : i4 = b * c + 21 - 3 * 2 + b

c : i4 = 1 + 2 * 3 + 1

d := i++;

while (d > a + c) {
    d = a
    c += 1
    if (d > c) {
        brk;
    }
}

list := [1,2,3,4,5]

foreach item in list with i {
    printf("this is the value at position {i} of list : {item}")
}

a : i4 = 12
b : i8 = 13

message :: string = "the values are a=" + a + " b=" + b
message :  string = "the values are a=" + a as string + " b=" + b as string

testCast : string = 12 as string + (13 + 15) as string

b : bool = (a and b as bool) or (c and (d and e)) and f

c : bool = function(a, 12 as string) as bool xor false

d : i4[] = [1,2,3,4,5]

e : i4[..] = d as i4[..]
f :: i4[] = d + e

g : i4[*] = [0]

for i:=1 to 100 {
    g += i
    g[i - 1] += i * 2 - i xor 3;
    a : i4 = 12; a += g[2]
}

a[1] = g[0] + g[1] + g[g[0] + g[1]]

g : i4[..] = 12

a[