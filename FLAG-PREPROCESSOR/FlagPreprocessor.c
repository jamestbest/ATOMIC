//
// Created by jamescoward on 09/11/2023.
//

#include "FlagPreprocessorInternal.h"

#include "../SharedIncludes/Messages.h"
#include "../TypePreprocessor/TypePreprocessorInternal.h"

#include <unistd.h>
#include <malloc.h>

#define ARGS_COUNT 3

bool verify_arguments(const int argc, char** argv);
char* get_cwd();

uint parse_flag_file(FILE* file);

void print_all_flaginfos(const Vector* vec);
void print_all_options(const Vector* vec);

Vector flagInfos;
Vector optionNames;

size_t l_pos = 0;

int compare_flag_infos(const void* a, const void* b) {
    const FlagInfo* flag_a = *(const FlagInfo**)a;
    const FlagInfo* flag_b = *(const FlagInfo**)b;

    return strcmp(flag_a->flag_name, flag_b->flag_name);
}

int cmp_str_to_flag(const void* a, const void* b) {
    const char* stra = a;
    const FlagInfo* flag = *(const FlagInfo**)b;

    return strcmp(stra, flag->flag_name);
}

size_t find_flag_loc(const char* flag_to_search) {
    const FlagInfo** res = bsearch(flag_to_search, flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), cmp_str_to_flag);

    if (res == NULL) return -1;
    return res - (const FlagInfo**)flagInfos.arr;
}

int main(const int argc, char** argv) {
    puts("Welcome to the ATOMIC Flag preprocessor");

    verify_arguments(argc, argv);

    flagInfos = vector_create(15);
    optionNames = vector_create(10);

    const char* flag_file_name = argv[1];
    FILE* flag_file = fopen(flag_file_name, "r");

    const uint ret = parse_flag_file(flag_file);

    if (ret != EXIT_SUCCESS) {
        error("Errors found during parsing of flag file, please fix and re-run. Errcode: %u", ret);
        return ret;
    }

    qsort(flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), compare_flag_infos);

    const char* output_file_name = argv[2];

    const uint write_res = write_out_flag_data(output_file_name);

    if (write_res != EXIT_SUCCESS) {
        error("Error during writing process\n");
    }

    vector_destroy(&flagInfos);
}

const char* translate_name_for_enum(const char* flag) {
    const uint len = strlen(flag);

    char* ret = malloc((len + 1) * sizeof (char));

    for (uint i = 0; i < len; ++i) {
        ret[i] = flag[i] == '-' ? '_' : flag[i];
    }
    ret[len] = '\0';

    return ret;
}

// [[todo]] change this to just be 2 functions, this is ridiculously obfuscated abstraction
void append_enum(FILE* file, const char* enum_name,
                 const char* enum_element_prefix,
                 const char* count_element_name, Vector* vector,
                 const char* (*get)(const size_t index)) {
    fprintf(file, "enum %s {\n", enum_name);
    for (uint i = 0; i < vector->pos; ++i) {
        const char* name = get(i);
        const char* translated_name = translate_name_for_enum(name);
        fprintf(file, "    %s%s,\n", enum_element_prefix, translated_name);
        free((void*)translated_name);
    }
    fprintf(file, "    %s%s\n};\n\n", enum_element_prefix, count_element_name);
}

const char* get_flag_name(const size_t index) {
    return ((FlagInfo*)flagInfos.arr[index])->flag_name;
}

void append_flag_enum(FILE* header_file) {
    append_enum(header_file,
        ATOM_FP__ENUM_FLAGS_NAME,
        ATOM_FP__FLAG_START,
        ATOM_FP__FLAGS_COUNT_NAME,
        &flagInfos,
        get_flag_name
    );
}

const char* get_option_name(const size_t index) {
    return optionNames.arr[index];
}

void append_option_enum(FILE* header_file) {
    append_enum(header_file,
        ATOM_FP__ENUM_OPTIONS_NAME,
        ATOM_FP__OPTION_START,
        ATOM_FP__OPTIONS_COUNT_NAME,
        &optionNames,
        get_option_name
    );
}

void write_header_out_preamble(FILE* header) {
    const time_t t = time(NULL);
    const struct tm *local_time = localtime(&t);
    char buff[32];
    const size_t res = strftime(buff, sizeof(buff), "%c", local_time);
    if (res == 0) {
        const char* errstr = "Error fetching date";
        memcpy(buff, errstr, strlen(errstr) + 1);
    }

    fprintf(header, "//\n"
           "// Generated by ATOM Flag Preprocessor:  %s\n"
           "//\n"
           "\n"
           "#ifndef "ATOM_FP__HEADER_GUARD"\n"
           "#define "ATOM_FP__HEADER_GUARD"\n"
           "\n"
           "#include <stdbool.h>\n"
           "\n",
           buff
    );

    fputs("typedef struct "ATOM_FP__FLAG_INFO_STRUCT_NAME" {\n"
      "    const char* "ATOM_FP__FLAG_INFO_STRUCT_STR_NAME";\n"
      "    bool "ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME";\n"
      "} "ATOM_FP__FLAG_INFO_STRUCT_NAME";\n\n",
      header
    );
}

void write_header_out_amble(FILE* header) {
    fputs("extern bool ATOM_VR__FLAGS["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"];\n"
             "extern FlagInfo ATOM_CT__FLAGINFO["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"];\n\n", header);
}

void write_header_out_examble(FILE* header) {
    fputs("#endif //"ATOM_FP__HEADER_GUARD, header);
}

void write_header_out(FILE* header) {
    write_header_out_preamble(header);

    append_flag_enum(header);
    append_option_enum(header);

    write_header_out_amble(header);
    write_header_out_examble(header);
}

void write_c_out_preamble(FILE* c_file, const char* header_output_filename) {
    fprintf(c_file, "#include \"%s.h\"\n\n", get_file_name(header_output_filename));
}

void write_c_out_flag_info_data(FILE* c_file) {
    fprintf(c_file, "const "ATOM_FP__FLAG_INFO_STRUCT_NAME" "ATOM_FP__FLAG_INFO_INSTANCE_NAME"[%s] = {\n", ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME);
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* translated_name = translate_name_for_enum(info->flag_name);

        fprintf(c_file, "    ["ATOM_FP__FLAG_START"%s] = ("ATOM_FP__FLAG_INFO_STRUCT_NAME"){."ATOM_FP__FLAG_INFO_STRUCT_STR_NAME"= \"%s\", ."ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME"= %s},\n",
            translated_name,
            info->flag_name,
            info->default_value ? "true" : "false"
        );

        free((void*)translated_name);
    }
    fputs("};\n\n", c_file);
}

void write_c_out_flag_array_data(FILE* c_file) {
    fprintf(c_file, "bool "ATOM_FP__FLAGS_ARRAY_NAME"["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"] = {\n");
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* value = info->default_value ? "true" : "false";

        fprintf(c_file, "    %s,\n", value);
    }
    fputs("};\n\n", c_file);
}

void write_c_out(FILE* c_file, const char* header_output_filename) {
    write_c_out_preamble(c_file, header_output_filename);
    write_c_out_flag_info_data(c_file);
    write_c_out_flag_array_data(c_file);
}

uint write_out_flag_data(const char* output_filename) {
    const char* temp_output_c_file_name = ATOM_FP__TEMP_FILENAME_STARTER".c";
    const char* temp_output_h_file_name = ATOM_FP__TEMP_FILENAME_STARTER".h";

    FILE* temp_c = fopen(temp_output_c_file_name, "w");
    FILE* temp_header = fopen(temp_output_h_file_name, "w");

    if (!temp_c || !temp_header) {
        error("Unable to open temporary file(s) for writing output. C: %s, H: %s", temp_c ? "OPENED" : "ERROR", temp_header ? "OPENED" : "ERROR");
        return EXIT_FAILURE;
    }

    write_header_out(temp_header);
    write_c_out(temp_c, output_filename);

    fclose(temp_c);
    fclose(temp_header);

    const char* c_out_filename = str_cat_dyn(output_filename, ".c");
    const char* h_out_filename = str_cat_dyn(output_filename, ".h");

    inform("Temp files written. (Over)Writing output files: `%s`, `%s`\n", c_out_filename, h_out_filename);

    // if the file exists then check it has been removed, else 0 (success)
    const int c_remove_res = access(c_out_filename, F_OK) == 0 ? remove(c_out_filename) : 0;
    const int c_remove_errno = errno;
    const int h_remove_res = access(h_out_filename, F_OK) == 0 ? remove(h_out_filename) : 0;
    const int h_remove_errno = errno;

    if (c_remove_res != 0 || h_remove_res != 0) {
        error("Unable to remove old files: `%s`: %s, `%s`: %s\n",
            c_out_filename,
            c_remove_res == 0 ? "REMOVED" : strerror(c_remove_errno),
            h_out_filename,
            h_remove_res == 0 ? "REMOVED" : strerror(h_remove_errno)
        );

        goto write_out_flag_data_out_file_cleanup;
    }

    const int c_rename_res = rename(temp_output_c_file_name, c_out_filename);
    const int c_rename_errno = errno;
    const int h_rename_res = rename(temp_output_h_file_name, h_out_filename);
    const int h_rename_errno = errno;

    if (c_rename_res != 0 || h_rename_res != 0) {
        error("Unable to rename file(s) for (Over)Writing: `%s`: %s, `%s`: %s\n",
            c_out_filename,
            c_rename_res == 0 ? "RENAMED" : strerror(c_rename_errno),
            h_out_filename,
            h_rename_res == 0 ? "RENAMED" : strerror(h_rename_errno)
        );

        goto write_out_flag_data_out_file_cleanup;
    }

    inform("All files written to. Exiting\n");

write_out_flag_data_out_file_cleanup:
    free((void*)c_out_filename);
    free((void*)h_out_filename);

    return EXIT_SUCCESS;
}

FlagInfo* create_flag_info(const char* name_start, const char* name_end, const char* default_start, const char* default_end) {
    FlagInfo* info = malloc(sizeof (FlagInfo));

    const size_t name_len = name_end - name_start;
    char* name = malloc((name_len + 1) * sizeof (char));
    memcpy(name, name_start, name_len);
    *(name + name_len) = '\0';

    const size_t default_len = default_end - default_start;
    const bool match_true = default_len + 1 == sizeof ("true") ? memcmp(default_start, "true", sizeof ("true") - 1) == 0 : false;
    const bool match_false = default_len + 1 == sizeof ("false") ? memcmp(default_start, "false", sizeof ("false") - 1) == 0 : false;

    if (!match_true && !match_false) {
        error("Given non true-false default value, read: `%s`", default_start);
        return NULL;
    }

    const bool default_value = match_true;

    info->flag_name = name;
    info->default_value = default_value;

    return info;
}

char* get_word_end(char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i])) {i++;};
    return word_start + i;
}

char* get_flag_or_option_end(char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i]) || word_start[i] == '-') {i++;};
    return word_start + i;
}

uint parse_keyword_flag(char* type_end) {
    char* name_start = strchr(type_end, ' ') + 1;
    const char* name_end = get_flag_or_option_end(name_start);

    char* default_start = strchr(name_end, ' ') + 1;
    const char* default_end = get_word_end(default_start);

    FlagInfo* info = create_flag_info(name_start, name_end, default_start, default_end);

    if (!info) return EXIT_FAILURE;

    vector_add(&flagInfos, info);

    return EXIT_SUCCESS;
}

uint parse_keyword_option(const char* type_end) {
    char* name_start = strchr(type_end, ' ') + 1;
    const char* name_end = get_flag_or_option_end(name_start);

    const uint name_len = name_end - name_start;
    char* name = malloc((name_len + 1) * sizeof (char));
    memcpy(name, name_start, name_len);
    *(name + name_len) = '\0';

    vector_add(&optionNames, name);

    return EXIT_SUCCESS;
}

int compare_keywords(const void* stra, const void* strb) {
    return strcmp(stra, *(char**)strb);
}

const char* get_tptoken_type_str(const FPToken* token) {
    return token_types_str[token->type];
}

void print_token_data(const FPToken* token) {
    switch (token->type) {
        case FP_IDENTIFIER:
            printf("%s", token->str);
            break;
        case FP_KEYWORD:
            printf("%s", keyword_str[token->keyword]);
            break;
        case FP_LIT_BOOL:
            printf("%s", token->boolean ? "true" : "false");
            break;
        case FP_LIT_INT:
            printf("%lld", token->integer);
            break;
        case FP_INVALID:
        default:
            putz("Invalid Data");
            break;
    }
}

void print_tptoken(const FPToken* token) {
    printf("TOK: %s (", get_tptoken_type_str(token));
    print_token_data(token);
    putchar(')');
}

FPToken lex_token(char* start, size_t max) {
    FPToken t = {.type = FP_INVALID};

    if (is_whitespace(*start) || is_newline(*start) || *start == '\0') {
        l_pos++;

        return t;
    }

    if (is_alph(*start)) {
        char* end = get_flag_or_option_end(start);
        const size_t bytes = end - start;

        if (!end) {
            assert(false);
        }

        if (bytes == STATIC_STRING_LEN("false") && strncmp(start, "false", bytes) == 0) {
            t.boolean = false;
            l_pos += STATIC_STRING_LEN("false");
        } else if (bytes == STATIC_STRING_LEN("true") && strncmp(start, "true", bytes) == 0) {
            t.boolean = true;
            l_pos += STATIC_STRING_LEN("true");
        } else {
            goto alph_cont;
        }

        t.type = FP_LIT_BOOL;
        return t;

    alph_cont:
        const char end_save = *end;
        *end = '\0';
        const char* const* res = bsearch(start, keyword_str, FP_KEYWORD_COUNT, sizeof (keyword_str[0]), compare_keywords);
        *end = end_save;

        if (!res) {
            // if it is not a keyword then it is an identifier
            char* ident = malloc(bytes);

            if (!ident) {
                panic("Malloc failed when allocating identifier");
            }

            memcpy(ident, start, bytes);
            *(ident + bytes) = '\0';

            t.type = FP_IDENTIFIER;
            t.str = ident;

            l_pos += bytes;
        } else {
            t.type = FP_KEYWORD;
            t.keyword = res - keyword_str;

            l_pos += strlen(*res);
        }
    } else if (is_digit(*start)) {
        char* end;
        const long long int value = strtoll(start, &end, 10);

        l_pos += end - start;

        t.type = FP_LIT_INT;
        t.integer = value;
    } else {
        warning("Found unidentifiable character `%c` (%d)\n", *start, *start);
        l_pos++;
    }

    return t;
}

struct LexRet {
    uint errcode;
    Array tokens;
} lex_flag_file(FILE* file) {
    Buffer line_buffer = buffer_create(BUFF_MIN);
    Array tokens = arr_create(sizeof(FPToken));
    uint errcode = EXIT_SUCCESS;

    while (get_line(file, &line_buffer)) {
        if (starts_with_ips(line_buffer.data, ATOM_FP__COMMENT_START) != -1) {
            // ignore whitespace, no tokens for it
            continue;
        }

        if (line_buffer.pos < 1) {
            continue;
        }

        if (line_buffer.pos == 1) {
            error("Found a single character when lexing file; `%c`, no single character lines mean anything.", line_buffer.data[0]);
            errcode = EXIT_FAILURE;
            continue;
        }

        const char c = line_buffer.data[0];
        const char n = line_buffer.data[1];
        if ((c == '\n' || (c == '\r' && n == '\n')) && line_buffer.pos <= 2) {
            // skip empty lines
            continue;
        }

        l_pos = 0;
        while (l_pos < line_buffer.pos) {
            FPToken t = lex_token(&line_buffer.data[l_pos], line_buffer.pos);

            if (t.type == FP_INVALID) continue;

            arr_add(&tokens, &t);
        }
    }

    for (uint i = 0; i < tokens.pos; ++i) {
        const FPToken* tok = arr_get(&tokens, i);
        print_tptoken(tok);
        newline();
    }

    return (struct LexRet){.errcode = errcode, .tokens = tokens};
}

uint parse_flag_file(FILE* file) {
    const struct LexRet ret = lex_flag_file(file);

    return ret.errcode;
}

void print_flaginfo(const FlagInfo* info) {
    printf("`%s`: %s"C_RST,
        info->flag_name,
        info->default_value ? C_GRN"true" : C_RED"false"
    );
}

void print_all_flaginfos(const Vector* vec) {
    puts("FLAG INFOS:");
    for (uint i = 0; i < vec->pos; ++i) {
        const FlagInfo* info = vec->arr[i];

        print_flaginfo(info);
        if (i != vec->pos) newline();
    }
}

void print_all_options(const Vector* vec) {
    puts("OPTIONS:");
    for (uint i = 0; i < vec->pos; ++i) {
        const char* const option = vec->arr[i];

        printf("%s",
            option
        );
        if (i != vec->pos) newline();
    }
}

bool verify_arguments(const int argc, char** argv) {
    if (argc != ARGS_COUNT) {
        usage("Format: ./Flag_Preprocessor <Flags file> <Output file>");
    }

    for (int i = 1; i < argc; ++i) {
        if (!argv[i]) {
            usage("NULL Argument, argument %d (1-indexed, ignoring ) is NULL", i);
        }
    }

    return EXIT_SUCCESS;
}
