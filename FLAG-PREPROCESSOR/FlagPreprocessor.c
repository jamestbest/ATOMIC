//
// Created by jamescoward on 09/11/2023.
//

#include "FlagPreprocessorInternal.h"

#include "../SharedIncludes/Messages.h"
#include "../TypePreprocessor/TypePreprocessorInternal.h"

#include <unistd.h>
#include <malloc.h>

#define ARGS_COUNT 3

bool verify_arguments(const int argc, char** argv);
char* get_cwd();

uint parse_flag_file(FILE* file);

void print_all_flaginfos(const Vector* vec);
void print_all_options(const Vector* vec);

Vector flagInfos;
Vector optionNames;

int compare_flag_infos(const void* a, const void* b) {
    const FlagInfo* flag_a = *(const FlagInfo**)a;
    const FlagInfo* flag_b = *(const FlagInfo**)b;

    return strcmp(flag_a->flag_name, flag_b->flag_name);
}

int cmp_str_to_flag(const void* a, const void* b) {
    const char* stra = a;
    const FlagInfo* flag = *(const FlagInfo**)b;

    return strcmp(stra, flag->flag_name);
}

size_t find_flag_loc(const char* flag_to_search) {
    const FlagInfo** res = bsearch(flag_to_search, flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), cmp_str_to_flag);

    if (res == NULL) return -1;
    return res - (const FlagInfo**)flagInfos.arr;
}

int main(const int argc, char** argv) {
    puts("Welcome to the ATOMIC Flag preprocessor");

    verify_arguments(argc, argv);

    flagInfos = vector_create(15);
    optionNames = vector_create(10);

    const char* flag_file_name = argv[1];
    FILE* flag_file = fopen(flag_file_name, "r");

    const uint ret = parse_flag_file(flag_file);

    if (ret != EXIT_SUCCESS) {
        error("Errors found during parsing of flag file, please fix and re-run. Errcode: %u", ret);
        return ret;
    }

    qsort(flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), compare_flag_infos);

    const char* output_file_name = argv[2];

    write_out_flag_data(output_file_name);

    print_all_flaginfos(&flagInfos);
    print_all_options(&optionNames);

    const char* test = "SCOPE-OUT";

    const size_t index = find_flag_loc(test);

    if (index != -1 && strcmp(*(char**)flagInfos.arr[index], test) == 0) {
        printf(C_GRN"SUCCESS"C_RST" got pos: %llu\n", index);
    } else {
        printf(C_RED"FAILED"C_RST" got pos: %llu\n", index);
    }

    vector_destroy(&flagInfos);
}

const char* translate_name_for_enum(const char* flag) {
    const uint len = strlen(flag);

    char* ret = malloc((len + 1) * sizeof (char));

    for (uint i = 0; i < len; ++i) {
        ret[i] = flag[i] == '-' ? '_' : flag[i];
    }
    ret[len] = '\0';

    return ret;
}

// [[todo]] change this to just be 2 functions, this is ridiculously obfuscated abstraction
uint append_enum(FILE* file, const char* enum_name, const char* enum_element_prefix, const char* count_element_name, Vector* vector, const char* (*get)(const size_t index)) {
    fprintf(file, "enum %s {\n", enum_name);
    for (uint i = 0; i < vector->pos; ++i) {
        const char* name = get(i);
        const char* translated_name = translate_name_for_enum(name);
        fprintf(file, "    %s%s,\n", enum_element_prefix, translated_name);
        free((void*)translated_name);
    }
    fprintf(file, "    %s%s\n};\n\n", enum_element_prefix, count_element_name);

    return EXIT_SUCCESS;
}

const char* get_flag_name(const size_t index) {
    return ((FlagInfo*)flagInfos.arr[index])->flag_name;
}

uint append_flag_enum(FILE* header_file) {
    return append_enum(header_file,
        ATOM_FP__ENUM_FLAGS_NAME,
        ATOM_FP__FLAG_START,
        ATOM_FP__FLAGS_COUNT_NAME,
        &flagInfos,
        get_flag_name
    );
}

const char* get_option_name(const size_t index) {
    return optionNames.arr[index];
}

uint append_option_enum(FILE* header_file) {
    return append_enum(header_file,
        ATOM_FP__ENUM_OPTIONS_NAME,
        ATOM_FP__OPTION_START,
        ATOM_FP__OPTIONS_COUNT_NAME,
        &optionNames,
        get_option_name
    );
}

uint write_header_out_preamble(FILE* header) {
    const time_t t = time(NULL);
    const struct tm *local_time = localtime(&t);
    char buff[32];
    const size_t res = strftime(buff, sizeof(buff), "%c", local_time);
    if (res == 0) {
        const char* errstr = "Error fetching date";
        memcpy(buff, errstr, strlen(errstr) + 1);
    }

    fprintf(header, "//\n"
           "// Generated by ATOM Flag Preprocessor:  %s\n"
           "//\n"
           "\n"
           "#ifndef "ATOM_FP__HEADER_GUARD"\n"
           "#define "ATOM_FP__HEADER_GUARD"\n"
           "\n"
           "#include <stdbool.h>\n"
           "\n",
           buff
    );
}

uint write_header_out_amble(FILE* header) {
    fputs("extern bool ATOM_VR__FLAGS["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"];\n", header);
}

uint write_header_out_examble(FILE* header) {
    fputs("#endif //"ATOM_FP__HEADER_GUARD, header);
}

uint write_header_out(FILE* header) {
    uint res = EXIT_SUCCESS;
    write_header_out_preamble(header);

    const uint flag_enum_res = append_flag_enum(header);

    if (flag_enum_res != EXIT_SUCCESS) {
        error("Error while writing flag enums to temp flag file");
        res = EXIT_FAILURE;
        goto write_out_flag_data_end;
    }

    const uint option_enum_res = append_option_enum(header);

    if (option_enum_res != EXIT_SUCCESS) {
        error("Error while writing option enums to temp flag file");
        res = EXIT_FAILURE;
        goto write_out_flag_data_end;
    }

write_out_flag_data_end:
    write_header_out_amble(header);
    write_header_out_examble(header);

    return res;
}

uint write_c_out_preamble(FILE* c_file) {
    fputs("#include \""ATOM_FP__TEMP_FILENAME_STARTER".h\"\n\n"
          "typedef struct "ATOM_FP__FLAG_INFO_STRUCT_NAME" {\n"
          "    const char* "ATOM_FP__FLAG_INFO_STRUCT_STR_NAME";\n"
          "    bool "ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME";\n"
          "} "ATOM_FP__FLAG_INFO_STRUCT_NAME";\n\n", c_file);
}

uint write_c_out_flag_info_data(FILE* c_file) {
    fprintf(c_file, "const "ATOM_FP__FLAG_INFO_STRUCT_NAME" "ATOM_FP__FLAG_INFO_INSTANCE_NAME"[%s] = {\n", ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME);
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* translated_name = translate_name_for_enum(info->flag_name);

        fprintf(c_file, "    ["ATOM_FP__FLAG_START"%s] = ("ATOM_FP__FLAG_INFO_STRUCT_NAME"){."ATOM_FP__FLAG_INFO_STRUCT_STR_NAME"= \"%s\", ."ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME"= %s},\n",
            translated_name,
            info->flag_name,
            info->default_value ? "true" : "false"
        );

        free((void*)translated_name);
    }
    fputs("};\n\n", c_file);
}

uint write_c_out_flag_array_data(FILE* c_file) {
    fprintf(c_file, "bool "ATOM_FP__FLAGS_ARRAY_NAME"["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"] = {\n");
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* value = info->default_value ? "true" : "false";

        fprintf(c_file, "    %s,\n", value);
    }
    fputs("};\n\n", c_file);
}

uint write_c_out(FILE* c_file) {
    write_c_out_preamble(c_file);
    write_c_out_flag_info_data(c_file);
    write_c_out_flag_array_data(c_file);
}

uint write_out_flag_data(const char* output_filename) {
    uint res = EXIT_SUCCESS;

    const char* temp_output_c_file_name = ATOM_FP__TEMP_FILENAME_STARTER".c";
    const char* temp_output_h_file_name = ATOM_FP__TEMP_FILENAME_STARTER".h";

    FILE* temp_c = fopen(temp_output_c_file_name, "w");
    FILE* temp_header = fopen(temp_output_h_file_name, "w");

    if (!temp_c || !temp_header) {
        error("Unable to open temporary file(s) for writing output. C: %s, H: %s", temp_c ? "OPENED" : "ERROR", temp_header ? "OPENED" : "ERROR");
        return EXIT_FAILURE;
    }

    const uint header_res = write_header_out(temp_header);
    if (header_res != EXIT_SUCCESS) {
        goto write_out_data_end;
    }

    const uint c_res = write_c_out(temp_c);
    if (c_res != EXIT_SUCCESS) {
        goto write_out_data_end;
    }

write_out_data_end:
    fclose(temp_c);
    fclose(temp_header);
}

FlagInfo* create_flag_info(const char* name_start, const char* name_end, const char* default_start, const char* default_end) {
    FlagInfo* info = malloc(sizeof (FlagInfo));

    const size_t name_len = name_end - name_start;
    char* name = malloc((name_len + 1) * sizeof (char));
    memcpy(name, name_start, name_len);
    *(name + name_len) = '\0';

    const size_t default_len = default_end - default_start;
    const bool match_true = default_len + 1 == sizeof ("true") ? memcmp(default_start, "true", sizeof ("true") - 1) == 0 : false;
    const bool match_false = default_len + 1 == sizeof ("false") ? memcmp(default_start, "false", sizeof ("false") - 1) == 0 : false;

    if (!match_true && !match_false) {
        error("Given non true-false default value, read: `%s`", default_start);
        return NULL;
    }

    const bool default_value = match_true;

    info->flag_name = name;
    info->default_value = default_value;

    return info;
}

const char* get_word_end(const char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i])) {i++;};
    return word_start + i;
}

const char* get_flag_or_option_end(const char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i]) || word_start[i] == '-') {i++;};
    return word_start + i;
}

uint parse_keyword_flag(const char* type_end) {
    const char* name_start = strchr(type_end, ' ') + 1;
    const char* name_end = get_flag_or_option_end(name_start);

    const char* default_start = strchr(name_end, ' ') + 1;
    const char* default_end = get_word_end(default_start);

    FlagInfo* info = create_flag_info(name_start, name_end, default_start, default_end);

    if (!info) return EXIT_FAILURE;

    vector_add(&flagInfos, info);

    return EXIT_SUCCESS;
}

uint parse_keyword_option(const char* type_end) {
    const char* name_start = strchr(type_end, ' ') + 1;
    const char* name_end = get_flag_or_option_end(name_start);

    const uint name_len = name_end - name_start;
    char* name = malloc((name_len + 1) * sizeof (char));
    memcpy(name, name_start, name_len);
    *(name + name_len) = '\0';

    vector_add(&optionNames, name);

    return EXIT_SUCCESS;
}

uint parse_flag_file(FILE* file) {
    Buffer line_buffer = buffer_create(50);
    uint errcode = EXIT_SUCCESS;

    while (get_line(file, &line_buffer)) {
        if (starts_with_ips(line_buffer.data, "//") != -1) {
            // this is a comment so skip
            continue;
        }

        const char c = line_buffer.data[0];
        const char n = line_buffer.data[1];
        if ((c == '\n' || (c == '\r' && n == '\n')) && line_buffer.pos <= 2) {
            // skip empty lines
            continue;
        }

        const char* type_start = line_buffer.data;
        const char* type_end = get_word_end(type_start);

        const uint max_len = type_end - type_start;
        uint ret;
        if (max_len == STATIC_STRING_LEN(ATOM_FP__KEYWORD_FLAG) && strncmp(type_start, ATOM_FP__KEYWORD_FLAG, max_len) == 0) {
            ret = parse_keyword_flag(type_end);
        } else if (max_len == STATIC_STRING_LEN(ATOM_FP__KEYWORD_OPTION) && strncmp(type_start, ATOM_FP__KEYWORD_OPTION, max_len) == 0) {
            ret = parse_keyword_option(type_end);
        } else {
            error("UNKNOWN KEYWORD: `%*.*s`\n",
                max_len, max_len, type_start
            );
            errcode = EXIT_FAILURE;
            continue;
        }

        if (ret != EXIT_SUCCESS) {
            errcode = ret;
        }
    }

    return errcode;
}

void print_flaginfo(const FlagInfo* info) {
    printf("`%s`: %s"C_RST,
        info->flag_name,
        info->default_value ? C_GRN"true" : C_RED"false"
    );
}

void print_all_flaginfos(const Vector* vec) {
    puts("FLAG INFOS:");
    for (int i = 0; i < vec->pos; ++i) {
        const FlagInfo* info = vec->arr[i];

        print_flaginfo(info);
        if (i != vec->pos) newline();
    }
}

void print_all_options(const Vector* vec) {
    puts("OPTIONS:");
    for (int i = 0; i < vec->pos; ++i) {
        const char* const option = vec->arr[i];

        printf("%s",
            option
        );
        if (i != vec->pos) newline();
    }
}

// getcwd with malloc
char* get_cwd() {
    int size = 50;
    char* buff = malloc(size * sizeof (char));
    char cap = 5;

    while (!getcwd(buff, size)) {
        if (!cap--) {
            free(buff);
            buff = NULL;
            break;
        }
        size <<= 1;
        char* new_buff = realloc(buff, size);

        if (!new_buff) return NULL;

        buff = new_buff;
    }

    return buff;
}

bool verify_arguments(const int argc, char** argv) {
    if (argc != ARGS_COUNT) {
        usage("Format: ./Flag_Preprocessor <Flags file> <Output file>");
    }

    for (int i = 1; i < argc; ++i) {
        if (!argv[i]) {
            usage("NULL Argument, argument %d (1-indexed, ignoring ) is NULL", i);
        }
    }

    return EXIT_SUCCESS;
}

int main2(int argc, char** argv) {
    puts("Welcome to the Flag preprocessor for ATOMIC\n");

    if (argc != 2) {
        puts(Error("Usage", ": ./Flag_Preprocessor <Dir of Flags.h & Flags.c>"));
        exit(1);
    }

    if (argv[1] == NULL) {
        puts(Error("Args", ": First cmd line arg is NULL"));
        exit(1);
    }

    const uint dir_len = len(argv[1]);

    char* dir_buff = malloc((dir_len + 1 + 20) * sizeof(char)); //+20 for the /Flags.c.c/h and FlagsTemp.c.c/h
    memcpy(dir_buff, argv[1], dir_len + 1);

    char* hpath = get_path(dir_buff, path_sep_s "Flags.h");
    char* cpath = get_path(dir_buff, path_sep_s "Flags.c");

    char* nhpath = get_path(dir_buff, path_sep_s "FlagsTemp.h");
    char* ncpath = get_path(dir_buff, path_sep_s "FlagsTemp.c");

    FILE* hptr = fopen(hpath, "r");
    FILE* cptr = fopen(cpath, "r");

    if (hptr == NULL || cptr == NULL) {
        printf(Error("FILE", ": Unable to open Flags.h or Flags.c.c. Current Dir: %s"), dir_buff);
        close_files(2, hptr, cptr);
        exit(2);
    }

    FILE* nhptr = fopen(nhpath, "w");
    FILE* ncptr = fopen(ncpath, "w");

    if (nhptr == NULL || ncptr == NULL) {
        printf(Error("FILE", ": Unable to create temp files. Current Dir: %s"), dir_buff);
        close_files(4, hptr, cptr, nhptr, ncptr);
        exit(2);
    }

    Vector flag_enums = vector_create(16);
    Vector option_enums = vector_create(16);

    parse_h(hptr, nhptr, &flag_enums, &option_enums);
    parse_c(cptr, ncptr, &flag_enums);

    free_enums(&flag_enums);
    free_enums(&option_enums);

    close_files(4, hptr, cptr, nhptr, ncptr);

    const int remh = remove(hpath);
    const int remc = remove(cpath);

    if (remh != 0 || remc != 0) {
        puts(Error("FileIO", ": Unable to remove file Flags.h/c.c\n"));
        exit(4);
    }

    const int renh = rename(nhpath, hpath);
    const int renc = rename(ncpath, cpath);

    if (renh != 0 || renc != 0) {
        puts(Error("FileIO", ": Unable to rename temp files to permanent\n"));
        exit(4);
    }

    free(dir_buff);
    free(cpath);
    free(hpath);
    free(nhpath);
    free(ncpath);

    vector_destroy(&flag_enums);
    vector_destroy(&option_enums);

    printf("SUCCESS! Files parsed and renamed");

    return 0;
}

void free_enums(Vector* enums) {
    for (uint i = 0; i < enums->pos; i++) {
        free(vector_get_unsafe(enums, i));
    }

    free(enums->arr);

    *enums = (Vector){NULL, -1, -1};
}

void close_files(uint file_count, ...) {
    va_list vl;

    va_start(vl, file_count);

    for (uint i = 0; i < file_count; i++) {
        FILE* file = va_arg(vl, FILE*);

        if (!file) continue;

        fclose(file);
    }
}

void parse_h(FILE* hptr, FILE* nhptr, Vector* flag_enums, Vector* option_enums) {
    Buffer buffer = buffer_create(32);

    while (get_line(hptr, &buffer)) {
        if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_OPT_ENUM) != -1) {
            collect_enums(hptr, nhptr, ATOM_CT__FLAGS_PRE_OPT_START, &buffer, option_enums);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_FLG_ENUM) != -1) {
            collect_enums(hptr, nhptr, ATOM_CT__FLAGS_PRE_FLG_START, &buffer, flag_enums);

            char* countEnum = vector_pop_unsafe(flag_enums); //remove the count
            free(countEnum);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_OPT_DEF) != -1) {
            parse_def(hptr, nhptr, option_enums, ATOM_CT__FLAGS_PRE_OPT_START, &buffer);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_FLG_DEF) != -1) {
            parse_def(hptr, nhptr, flag_enums, ATOM_CT__FLAGS_PRE_FLG_START, &buffer);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_FLG_STR) != -1) {
            parse_string(hptr, nhptr, flag_enums, ATOM_CT__FLAGS_PRE_FLG_START, &buffer);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_OPT_STR) != -1) {
            parse_string(hptr, nhptr, option_enums, ATOM_CT__FLAGS_PRE_OPT_START, &buffer);
        }
        else {
            fputs(buffer.data, nhptr);
        }
    }

    buffer_destroy(&buffer);
}

void parse_string(FILE* file, FILE* nfile, Vector* enums, const char* prefix, Buffer* buffer) {
    fputs(buffer->data, nfile); //write the //%%XXXX STRINGS%%

    for (uint i = 0; i < enums->pos; i++) {
        const char* current_enum = enums->arr[i];

        fprintf(nfile, "#define %s%s_STR \"%s\"\n", prefix, current_enum, current_enum);
    }

    cleanup_skip(file, nfile, buffer);
}

void parse_def(FILE* file, FILE* nfile, Vector* enums, const char* prefix, Buffer* buffer) {
    fputs(buffer->data, nfile); //write the //%%XXXX DEFINE%%

    for (uint i = 0; i < enums->pos; i++) {
        const char* current_enum = enums->arr[i];
        char* current_enum_dashed = str_cpy_replace(current_enum, '_', '-');

        fprintf(nfile, "#define %s%s_HASH 0x%llx\n", prefix, current_enum, flag_to_int(current_enum_dashed));

        free(current_enum_dashed);
    }

    cleanup_skip(file, nfile, buffer);
}

void parse_c(FILE* cptr, FILE* ncptr, Vector* flag_enums) {
    Buffer buffer = buffer_create(32);
    while (get_line(cptr,&buffer)) {
        if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_FLG_IDX_SWT) != -1) {
            parse_switch(cptr, ncptr, ATOM_CT__FLAGS_PRE_FLG_START, "", "_HASH", "-1", &buffer, flag_enums);
        }
        else if (starts_with_ips(buffer.data, ATOM_CT__FLAGS_PRE_FLG_STR_SWT) != -1) {
            parse_switch(cptr, ncptr, ATOM_CT__FLAGS_PRE_FLG_START, "_STR", "", "\"ERROR NO ENUM NAME\"", &buffer, flag_enums);
        }
        else {
            fputs(buffer.data, ncptr);
        }
    }

    buffer_destroy(&buffer);
}

void parse_switch(FILE* file, FILE* nfile, const char* prefix,
                  const char* to, const char* from, const char* default_value,
                  Buffer* buffer, Vector* flag_enums) {

    fputs(buffer->data, nfile); //write the %%XX%%

    for (uint i = 0; i < flag_enums->pos; i++) {
        const char* flag_name = flag_enums->arr[i];

        fprintf(nfile, "\t\tcase %s%s%s:\n"
                       "\t\t\treturn %s%s%s;\n", prefix, flag_name, from, prefix, flag_name, to);
    }
    fprintf(nfile, "\t\tdefault:\n"
                   "\t\t\treturn %s;\n", default_value);

    cleanup_skip(file, nfile, buffer);
}

/*
* Find the next %%END%% while writing to the newfile
*/
void cleanup_write(FILE* file, FILE* nfile, Buffer* buffer) {
    fputs(buffer->data, nfile);

    while (get_line(file, buffer)) {
        fputs(buffer->data, nfile);
        if (starts_with_ips(buffer->data, ATOM_CT__FLAGS_PRE_END)) {
            break;
        }
    }
}

/*
 * Find the next %%END%% skip writing to the nfile bar the end phrase
 */
void cleanup_skip(FILE* file, FILE* nfile, Buffer* buffer) {
    while (get_line(file, buffer)) {
        if (starts_with_ips(buffer->data, ATOM_CT__FLAGS_PRE_END) != -1) {
            break;
        }
    }
    fputs(buffer->data, nfile); //write the `//%%END%%`
}

void collect_enums(FILE* file, FILE* nfile, const char* prefix, Buffer* buffer, Vector* enum_vec) {
    //We're at the //%%XXXX ENUM%% label so write this to the file
    fputs(buffer->data, nfile);

    get_line(file, buffer);
    if (starts_with_ips(buffer->data, "enum") == -1) {
        puts(Error("FLAG.c.c", ": enum not found after //%%XXXX ENUM%%"));
    }
    fputs(buffer->data, nfile);

    while (get_line(file, buffer)) {
        int pos = starts_with_ips(buffer->data, prefix);
        if (pos == -1) {
            break;
        }

        fputs(buffer->data, nfile);

        const uint tot_length = len_from_to(buffer->data, pos, ',') + 1;

        char* s_enum = malloc(tot_length * sizeof(char));
        memcpy(s_enum, &buffer->data[pos], tot_length);
        s_enum[tot_length - 1] = '\0';

        vector_add(enum_vec, s_enum);
    }
    cleanup_write(file, nfile, buffer);
}
