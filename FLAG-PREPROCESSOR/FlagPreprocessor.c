//
// Created by jamescoward on 09/11/2023.
//

#include "FlagPreprocessorInternal.h"

#include "../SharedIncludes/Messages.h"
#include "../TypePreprocessor/TypePreprocessorInternal.h"

#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define ARGS_COUNT 3

bool verify_arguments(const int argc, char** argv);
char* get_cwd();

uint parse_flag_file(FILE* file);

void print_all_flaginfos(const Vector* vec);
void print_all_options(const Vector* vec);

Vector flagInfos;
Vector optionInfos;

size_t l_pos;
size_t p_pos;
Array tokens;

int compare_flag_infos(const void* a, const void* b) {
    const FlagInfo* flag_a = *(const FlagInfo**)a;
    const FlagInfo* flag_b = *(const FlagInfo**)b;

    return strcmp(flag_a->flag_name, flag_b->flag_name);
}

int cmp_str_to_flag(const void* a, const void* b) {
    const char* stra = a;
    const FlagInfo* flag = *(const FlagInfo**)b;

    return strcmp(stra, flag->flag_name);
}

size_t find_flag_loc(const char* flag_to_search) {
    const FlagInfo** res = bsearch(flag_to_search, flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), cmp_str_to_flag);

    if (res == NULL) return -1;
    return res - (const FlagInfo**)flagInfos.arr;
}

int main(const int argc, char** argv) {
    puts("Welcome to the ATOMIC Flag preprocessor");

    verify_arguments(argc, argv);

    flagInfos = vector_create(15);
    optionInfos = vector_create(10);

    const char* flag_file_name = argv[1];
    FILE* flag_file = fopen(flag_file_name, "r");

    const uint ret = parse_flag_file(flag_file);

    if (ret != EXIT_SUCCESS) {
        error("Errors found during parsing of flag file, please fix and re-run. Errcode: %u\n", ret);
        return ret;
    }

    qsort(flagInfos.arr, flagInfos.pos, sizeof (FlagInfo*), compare_flag_infos);

    const char* output_file_name = argv[2];

    const uint write_res = write_out_flag_data(output_file_name);

    if (write_res != EXIT_SUCCESS) {
        error("Error during writing process\n");
    }

    vector_destroy(&flagInfos);
}

const char* translate_name_for_enum(const char* flag) {
    const uint len = strlen(flag);

    char* ret = malloc((len + 1) * sizeof (char));

    for (uint i = 0; i < len; ++i) {
        ret[i] = flag[i] == '-' ? '_' : flag[i];
    }
    ret[len] = '\0';

    return ret;
}

// [[todo]] change this to just be 2 functions, this is ridiculously obfuscated abstraction
void append_enum(FILE* file, const char* enum_name,
                 const char* enum_element_prefix,
                 const char* count_element_name,
                 const Vector* vector,
                 const char* (*get)(const size_t index)) {
    fprintf(file, "enum %s {\n", enum_name);
    for (uint i = 0; i < vector->pos; ++i) {
        const char* name = get(i);
        const char* translated_name = translate_name_for_enum(name);
        fprintf(file, "    %s%s,\n", enum_element_prefix, translated_name);
        free((void*)translated_name);
    }
    fprintf(file, "    %s%s\n};\n\n", enum_element_prefix, count_element_name);
}

const char* get_flag_name(const size_t index) {
    return ((FlagInfo*)flagInfos.arr[index])->flag_name;
}

void append_flag_enum(FILE* header_file) {
    append_enum(header_file,
        ATOM_FP__ENUM_FLAGS_NAME,
        ATOM_FP__FLAG_START,
        ATOM_FP__FLAGS_COUNT_NAME,
        &flagInfos,
        get_flag_name
    );
}

const char* get_option_name(const size_t index) {
    return ((OptionInfo*)vector_get_unsafe(&optionInfos, index))->option_name;
}

void append_option_enum(FILE* header_file) {
    append_enum(header_file,
        ATOM_FP__ENUM_OPTIONS_NAME,
        ATOM_FP__OPTION_START,
        ATOM_FP__OPTIONS_COUNT_NAME,
        &optionInfos,
        get_option_name
    );
}

void write_header_out_preamble(FILE* header) {
    const time_t t = time(NULL);
    const struct tm *local_time = localtime(&t);
    char buff[32];
    const size_t res = strftime(buff, sizeof(buff), "%c", local_time);
    if (res == 0) {
        const char* errstr = "Error fetching date";
        memcpy(buff, errstr, strlen(errstr) + 1);
    }

    fprintf(header, "//\n"
           "// Generated by ATOM Flag Preprocessor:  %s\n"
           "//\n"
           "\n"
           "#ifndef "ATOM_FP__HEADER_GUARD"\n"
           "#define "ATOM_FP__HEADER_GUARD"\n"
           "\n"
           "#include <stdbool.h>\n"
           "\n",
           buff
    );

    fputs("typedef struct "ATOM_FP__FLAG_INFO_STRUCT_NAME" {\n"
      "    const char* "ATOM_FP__FLAG_INFO_STRUCT_STR_NAME";\n"
      "    bool "ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME";\n"
      "} "ATOM_FP__FLAG_INFO_STRUCT_NAME";\n\n",
      header
    );
}

void write_header_out_amble(FILE* header) {
    fputs("extern bool ATOM_VR__FLAGS["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"];\n"
             "extern FlagInfo ATOM_CT__FLAGINFO["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"];\n\n", header);
}

void write_header_out_examble(FILE* header) {
    fputs("#endif //"ATOM_FP__HEADER_GUARD, header);
}

void write_header_out(FILE* header) {
    write_header_out_preamble(header);

    append_flag_enum(header);
    append_option_enum(header);

    write_header_out_amble(header);
    write_header_out_examble(header);
}

void write_c_out_preamble(FILE* c_file, const char* header_output_filename) {
    fprintf(c_file, "#include \"%s.h\"\n\n", get_file_name(header_output_filename));
}

void write_c_out_flag_info_data(FILE* c_file) {
    fprintf(c_file, "const "ATOM_FP__FLAG_INFO_STRUCT_NAME" "ATOM_FP__FLAG_INFO_INSTANCE_NAME"[%s] = {\n", ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME);
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* translated_name = translate_name_for_enum(info->flag_name);

        fprintf(c_file, "    ["ATOM_FP__FLAG_START"%s] = ("ATOM_FP__FLAG_INFO_STRUCT_NAME"){."ATOM_FP__FLAG_INFO_STRUCT_STR_NAME"= \"%s\", ."ATOM_FP__FLAG_INFO_STRUCT_DEF_NAME"= %s},\n",
            translated_name,
            info->flag_name,
            info->default_value ? "true" : "false"
        );

        free((void*)translated_name);
    }
    fputs("};\n\n", c_file);
}

void write_c_out_flag_array_data(FILE* c_file) {
    fprintf(c_file, "bool "ATOM_FP__FLAGS_ARRAY_NAME"["ATOM_FP__FLAG_START ATOM_FP__FLAGS_COUNT_NAME"] = {\n");
    for (uint i = 0; i < flagInfos.pos; ++i) {
        const FlagInfo* info = flagInfos.arr[i];
        const char* value = info->default_value ? "true" : "false";

        fprintf(c_file, "    %s,\n", value);
    }
    fputs("};\n\n", c_file);
}

void write_c_out(FILE* c_file, const char* header_output_filename) {
    write_c_out_preamble(c_file, header_output_filename);
    write_c_out_flag_info_data(c_file);
    write_c_out_flag_array_data(c_file);
}

uint write_out_flag_data(const char* output_filename) {
    const char* temp_output_c_file_name = ATOM_FP__TEMP_FILENAME_STARTER".c";
    const char* temp_output_h_file_name = ATOM_FP__TEMP_FILENAME_STARTER".h";

    FILE* temp_c = fopen(temp_output_c_file_name, "w");
    FILE* temp_header = fopen(temp_output_h_file_name, "w");

    if (!temp_c || !temp_header) {
        error("Unable to open temporary file(s) for writing output. C: %s, H: %s\n", temp_c ? "OPENED" : "ERROR", temp_header ? "OPENED" : "ERROR");
        return EXIT_FAILURE;
    }

    write_header_out(temp_header);
    write_c_out(temp_c, output_filename);

    fclose(temp_c);
    fclose(temp_header);

    const char* c_out_filename = str_cat_dyn(output_filename, ".c");
    const char* h_out_filename = str_cat_dyn(output_filename, ".h");

    inform("Temp files written. (Over)Writing output files: `%s`, `%s`\n", c_out_filename, h_out_filename);

    // if the file exists then check it has been removed, else 0 (success)
    const int c_remove_res = access(c_out_filename, F_OK) == 0 ? remove(c_out_filename) : 0;
    const int c_remove_errno = errno;
    const int h_remove_res = access(h_out_filename, F_OK) == 0 ? remove(h_out_filename) : 0;
    const int h_remove_errno = errno;

    if (c_remove_res != 0 || h_remove_res != 0) {
        error("Unable to remove old files: `%s`: %s, `%s`: %s\n",
            c_out_filename,
            c_remove_res == 0 ? "REMOVED" : strerror(c_remove_errno),
            h_out_filename,
            h_remove_res == 0 ? "REMOVED" : strerror(h_remove_errno)
        );

        goto write_out_flag_data_out_file_cleanup;
    }

    const int c_rename_res = rename(temp_output_c_file_name, c_out_filename);
    const int c_rename_errno = errno;
    const int h_rename_res = rename(temp_output_h_file_name, h_out_filename);
    const int h_rename_errno = errno;

    if (c_rename_res != 0 || h_rename_res != 0) {
        error("Unable to rename file(s) for (Over)Writing: `%s`: %s, `%s`: %s\n",
            c_out_filename,
            c_rename_res == 0 ? "RENAMED" : strerror(c_rename_errno),
            h_out_filename,
            h_rename_res == 0 ? "RENAMED" : strerror(h_rename_errno)
        );

        goto write_out_flag_data_out_file_cleanup;
    }

    inform("All files written to. Exiting\n");

write_out_flag_data_out_file_cleanup:
    free((void*)c_out_filename);
    free((void*)h_out_filename);

    return EXIT_SUCCESS;
}

FlagInfo* create_flag_info(FPToken* identifier, FPToken* default_value) {
    if (!identifier || !default_value) {
        assert(false);
    }

    FlagInfo* info = malloc(sizeof(FlagInfo));

    *info = (FlagInfo) {
        .flag_name = identifier->str,
        .default_value = default_value->boolean
    };

    return info;
}

OptionArgInfo* create_arg_info(FPToken const* identifier, FPToken const* type, const Array arg_options) {
    OptionArgInfo* info = malloc(sizeof(OptionArgInfo));

    *info = (OptionArgInfo) {
        .arg_name = identifier->str,
        .type = type->type_enum,
        .arg_options = arg_options
    };

    return info;
}

OptionInfo* create_option_info(const FPToken* identifier) {
    OptionInfo* info = malloc(sizeof(OptionInfo));

    *info = (OptionInfo){
        .arg_infos = vector_create(3),
        .option_name = identifier->str
    };

    return info;
}

char* get_word_end(char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i])) {i++;};
    return word_start + i;
}

char* get_flag_or_option_end(char* word_start) {
    size_t i = 0;
    while (is_alph(word_start[i]) || word_start[i] == '-') {i++;};
    return word_start + i;
}

int compare_strings(const void* stra, const void* strb) {
    return strcmp(stra, *(char**)strb);
}

const char* get_tptoken_type_str(const FPToken* token) {
    return token_types_str[token->type];
}

void print_token_data(const FPToken* token) {
    switch (token->type) {
        case FP_IDENTIFIER:
            printf("%s", token->str);
            break;
        case FP_TYPE:
            printf("%s", types_str[token->type_enum]);
            break;
        case FP_KEYWORD:
            printf("%s", keyword_str[token->keyword_enum]);
            break;
        case FP_LIT_BOOL:
            printf("%s", token->boolean ? "true" : "false");
            break;
        case FP_LIT_INT:
            printf("%lld", token->integer);
            break;
        case FP_COMMA:
            putchar(',');
            break;
        case FP_COUNT:
            putz("How did we get here?");
            break;
        case FP_INVALID:
        default:
            putz("Invalid Data");
            break;
    }
}

void print_tptoken(const FPToken* token) {
    printf("TOK: %s (", get_tptoken_type_str(token));
    print_token_data(token);
    putchar(')');
}

FPToken lex_token(char* start) {
    FPToken t = {.type = FP_INVALID};

    if (is_whitespace(*start) || is_newline(*start) || *start == '\0') {
        l_pos++;

        return t;
    }

    if (*start == ',') {
        t.type = FP_COMMA;

        l_pos++;
        return t;
    }

    if (is_alph(*start)) {
        char* end = get_flag_or_option_end(start);
        const size_t bytes = end - start;

        if (!end) {
            assert(false);
        }

        if (bytes == STATIC_STRING_LEN("false") && strncmp(start, "false", bytes) == 0) {
            t.boolean = false;
            l_pos += STATIC_STRING_LEN("false");
        } else if (bytes == STATIC_STRING_LEN("true") && strncmp(start, "true", bytes) == 0) {
            t.boolean = true;
            l_pos += STATIC_STRING_LEN("true");
        } else {
            goto alph_cont;
        }

        t.type = FP_LIT_BOOL;
        return t;

    alph_cont:;
        const char end_save = *end;
        *end = '\0';
        const char* const* type_res = bsearch(start, types_str, FP_TYPES_COUNT, sizeof (types_str[0]), compare_strings);
        const char* const* keyword_res = bsearch(start, keyword_str, FP_KEYWORD_COUNT, sizeof (keyword_str[0]), compare_strings);
        *end = end_save;

        if (keyword_res && type_res) {
            assert(false);
        }

        if (keyword_res) {
            t.type = FP_KEYWORD;
            t.keyword_enum = keyword_res - keyword_str;

            l_pos += strlen(*keyword_res);
        } else if (type_res) {
            t.type = FP_TYPE;
            t.type_enum = type_res - types_str;

            l_pos += strlen(*type_res);
        } else {
            // if it is not a keyword then it is an identifier
            char* ident = malloc(bytes);

            if (!ident) {
                panic("Malloc failed when allocating identifier");
            }

            memcpy(ident, start, bytes);
            *(ident + bytes) = '\0';

            t.type = FP_IDENTIFIER;
            t.str = ident;

            l_pos += bytes;
        }
    } else if (is_digit(*start)) {
        char* end;
        const long long int value = strtoll(start, &end, 10);

        l_pos += end - start;

        t.type = FP_LIT_INT;
        t.integer = value;
    } else {
        warning("Found unidentifiable character `%c` (%d)\n", *start, *start);
        l_pos++;
    }

    return t;
}

uint lex_flag_file(FILE* file) {
    Buffer line_buffer = buffer_create(BUFF_MIN);
    tokens = arr_create(sizeof(FPToken));
    uint errcode = EXIT_SUCCESS;

    while (get_line(file, &line_buffer)) {
        if (starts_with_ips(line_buffer.data, ATOM_FP__COMMENT_START) != -1) {
            // ignore whitespace, no tokens for it
            continue;
        }

        if (line_buffer.pos < 1) {
            continue;
        }

        if (line_buffer.pos == 1) {
            error("Found a single character when lexing file; `%c`, no single character lines mean anything.\n", line_buffer.data[0]);
            errcode = EXIT_FAILURE;
            continue;
        }

        const char c = line_buffer.data[0];
        const char n = line_buffer.data[1];
        if ((c == '\n' || (c == '\r' && n == '\n')) && line_buffer.pos <= 2) {
            // skip empty lines
            continue;
        }

        l_pos = 0;
        while (l_pos < line_buffer.pos) {
            FPToken t = lex_token(&line_buffer.data[l_pos]);

            if (t.type == FP_INVALID) continue;

            arr_add(&tokens, &t);
        }
    }

    for (uint i = 0; i < tokens.pos; ++i) {
        const FPToken* tok = arr_get(&tokens, i);
        print_tptoken(tok);
        newline();
    }

    return errcode;
}

FPToken* consume() {
    if (p_pos >= tokens.pos) {
        return NULL;
    }

    return arr_get(&tokens, p_pos++);
}

FPToken* peek() {
    if (p_pos + 1 >= tokens.pos) {
        return NULL;
    }

    return arr_get(&tokens, p_pos + 1);
}

FPToken* expect(const TokenType type) {
    if (p_pos >= tokens.pos) return NULL;

    if (((FPToken*)arr_get(&tokens, p_pos))->type != type) {
        return NULL;
    }

    return consume(); // eat the keyword (๑ᵔ⤙ᵔ๑)
}

FPToken* expect_keyword(Keywords keyword) {
    const FPToken* tok = (FPToken*)arr_get(&tokens, p_pos);

    if (tok->type != FP_KEYWORD) {
        return NULL;
    }

    if (tok->keyword_enum != keyword) {
        return NULL;
    }

    return consume();
}

uint parse_keyword_flag() {
    FPToken* identifier = expect(FP_IDENTIFIER);

    if (!identifier) {
        error("Expected an identifier after FLAG keyword\n");
        return EXIT_FAILURE;
    }

    FPToken* default_value = expect(FP_LIT_BOOL);

    if (!default_value) {
        error("Expected a lit boolean after Identifier in FLAG keyword\n");
        return EXIT_FAILURE;
    }

    FlagInfo* finfo = create_flag_info(identifier, default_value);

    if (!finfo) {
        assert(false);
    }

    vector_add(&flagInfos, finfo);

    return EXIT_SUCCESS;
}

uint parse_keyword_option() {
    FPToken* identifier = expect(FP_IDENTIFIER);

    if (!identifier) {
        error("Expected an identifier after OPTION keyword\n");
        return EXIT_FAILURE;
    }

    OptionInfo* info = create_option_info(identifier);
    vector_add(&optionInfos, info);

    return EXIT_SUCCESS;
}


uint parse_keyword_arg() {
    FPToken* identifier = expect(FP_IDENTIFIER);

    if (!identifier) {
        error("Expected identifier after keyword ARG for argument name\n");
        return EXIT_FAILURE;
    }

    FPToken* type_keyword = expect_keyword(FP_KEYWORD_TYPE);

    if (!type_keyword) {
        error("Expected type keyword after identifier in ARG statement\n");
        return EXIT_FAILURE;
    }

    FPToken* type = expect(FP_TYPE);

    if (!type) {
        error("Expected type after type keyword in ARG statement\n");
        return EXIT_FAILURE;
    }

    Array arg_options;

    switch (type->type_enum) {
        case FP_TYPE_STR:
            arg_options = arr_create(sizeof (char*));
            break;
        case FP_TYPE_INTEGER:
        case FP_TYPE_NATURAL:
            arg_options = arr_create(sizeof (long long int));
            break;
        case FP_TYPE_CHARACTER:
            arg_options = arr_create(sizeof (char));
            break;
        default:
            assert(false);
    }

    if (expect_keyword(FP_KEYWORD_FROM)) {
        bool first_time = true;

        while (first_time || expect(FP_COMMA)) {
            first_time = false;
            FPToken* value;

            switch (type->type_enum) {
                case FP_TYPE_STR:
                    value = expect(FP_IDENTIFIER);
                    if (!value) goto identifier_error;
                    arr_add(&arg_options, value->str);
                    break;
                case FP_TYPE_INTEGER:
                case FP_TYPE_NATURAL:
                    value = expect(FP_LIT_INT);
                    if (!value) goto identifier_error;
                    arr_add(&arg_options, &value->integer);
                    break;
                case FP_TYPE_CHARACTER:
                    value = expect(FP_IDENTIFIER);
                    if (!value) goto identifier_error;
                    arr_add(&arg_options, value->str);
                    break;
                default:
                    assert(false);

            }
            goto identifier_cont;

        identifier_error:
            error("Expected identifier in FROM list");
            return EXIT_FAILURE;
        identifier_cont:
        }
    }

    OptionArgInfo* info = create_arg_info(identifier, type, arg_options);
    vector_add(&optionInfos, info);

    return EXIT_SUCCESS;
}

uint parse_token(const FPToken* token) {
    const Keywords enum_pos = token->keyword_enum;

    switch (enum_pos) {
        case FP_KEYWORD_FLAG:
            parse_keyword_flag();
            break;
        case FP_KEYWORD_OPTION:
            parse_keyword_option();
            break;
        case FP_KEYWORD_ARG:
            parse_keyword_arg();
            break;
        default:
            error("Invalid keyword used as a statement starter. Found %s\n", keyword_str[enum_pos]);
            break;
    }
}

uint parse_flag_file(FILE* file) {
    const uint ret = lex_flag_file(file);

    if (ret != EXIT_SUCCESS) {
        error("Errors generated from lexing, errcode %u\n", ret);
        return ret;
    }

    if (tokens.pos == 0) {
        warning("No tokens were generated from the lexing stage\n");
        return EXIT_SUCCESS;
    }

    while (peek()) {
        const FPToken* c = consume();

        if (c->type != FP_KEYWORD) {
            error("Found non keyword at start of statement parsing. Found: %s\n", token_types_str[c->type]);
            return EXIT_FAILURE;
        }

        parse_token(c);
    }

    return ret;
}

void print_flaginfo(const FlagInfo* info) {
    printf("`%s`: %s"C_RST,
        info->flag_name,
        info->default_value ? C_GRN"true" : C_RED"false"
    );
}

void print_all_flaginfos(const Vector* vec) {
    puts("FLAG INFOS:");
    for (uint i = 0; i < vec->pos; ++i) {
        const FlagInfo* info = vec->arr[i];

        print_flaginfo(info);
        if (i != vec->pos) newline();
    }
}

void print_all_options(const Vector* vec) {
    puts("OPTIONS:");
    for (uint i = 0; i < vec->pos; ++i) {
        const char* const option = vec->arr[i];

        printf("%s",
            option
        );
        if (i != vec->pos) newline();
    }
}

bool verify_arguments(const int argc, char** argv) {
    if (argc != ARGS_COUNT) {
        usage("Format: ./Flag_Preprocessor <Flags file> <Output file>");
    }

    for (int i = 1; i < argc; ++i) {
        if (!argv[i]) {
            usage("NULL Argument, argument %d (1-indexed, ignoring ) is NULL", i);
        }
    }

    return EXIT_SUCCESS;
}
